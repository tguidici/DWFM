% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DWFM_algo.R
\name{logFC_mat}
\alias{logFC_mat}
\title{Calculates the pseudo-log fold change between all 2-way comparisons of interest}
\usage{
logFC_mat(Bhat, contrasts, condit_names)
}
\arguments{
\item{Bhat}{Bhat matrix from the output of \code{estimateBkQ()}}

\item{contrasts}{a matrix with 2 columns and n rows, specifying the \code{n} total 2-way comparisons of interest.}

\item{condit_names}{Names of each of the conditions/datasets of interest.}
}
\value{
A matrix with one column for each row of \code{contrasts}. Note that \code{Nan}, \code{Inf}, and \code{-Inf} values are set to \code{0}
}
\description{
Calculates \code{log2(Bhat[i,j]/Bhat[i,k])} where \code{j,k} are specified via \code{contrasts} matrix
}
\examples{
sparse_params <- covmats_etc <- vector(mode="list", length=2)
for(i in 1:length(sparse_params)){
 covmats_etc[[i]] <- step0(X[[i]],2)
 sparse_params[[i]] <- sparse_lambdahat_cardinality(covmats_etc[[i]])
}
#we need to rotate all lambdahats to the ture Lambda values before sparsifying
lambdahat_proc <- vector(mode="list", length=2)
lambdahat_proc[[1]] <- covmats_etc[[1]]$lambdahat
lambdahat_proc[[2]] <- covmats_etc[[2]]$lambdahat
for(j in 1:length(covmats_etc)){
 for(i in 1:dim(covmats_etc[[j]]$lambdahat)[3]){
  lambdahat_proc[[j]][,,i] <- vegan::procrustes(Lambda_vals[[j]][,,i],
  covmats_etc[[j]]$lambdahat[,,i], scale=FALSE, symmetric=FALSE)$Yrot
 }
}
#sparsify
spca_cutoff = 0.01
sps_lambdahat_proc = lambdahat_proc
for(j in 1:length(lambdahat_proc)){
sps_lambdahat_proc$C[[j]] <- trunc_C(lambdahat_proc[[j]], sparse_params[[j]]$col_card)
}
#run the algorithm
test_algo <- vector(mode="list", length=2)
test_algo[[1]] <- estimateBkQ(sps_lambdahat_proc$C[[1]], constraint = 1, qadj = "n")
test_algo[[2]] <- estimateBkQ(sps_lambdahat_proc$C[[2]], constraint = 3,
norm_groups = list(c(1,2), c(3,4) ), qadj = "n")
#create reconstructed covariance and lambdahat matrices
reconstructed_output <- vector(mode="list", length=2)
for(i in 1:length(reconstructed_output)){
 reconstructed_output[[i]] <- recon_covlh(test_algo[[i]])
}
#calculate psuedo-LFC values
contrast_mat <- logfc <- vector(mode="list", length=2)
contrast_mat[[1]] <- matrix(data = c(1,2,1,3,2,3), ncol = 2, byrow=TRUE)
contrast_mat[[2]] <- matrix(data = c(1,2,3,4,1,3,2,4), ncol=2, byrow = TRUE)
logfc[[1]] <- logFC_mat(test_algo[[1]]$Bhat,contrasts=contrast_mat[[1]],
condit_names= c("c1", "c2", "c3"))
logfc[[2]] <- logFC_mat(test_algo[[2]]$Bhat,contrasts=contrast_mat[[2]],
condit_names= c("c1", "c2", "c3", "c4"))
}
