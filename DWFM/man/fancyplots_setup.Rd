% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DWFM_fa_viz.R
\name{fancyplots_setup}
\alias{fancyplots_setup}
\title{Make all necessary heatmaps and bar charts for fancy plots}
\usage{
fancyplots_setup(pseudo_LFC, CovMat_est, subset_order, subset_name = NULL,
  color_pal = bluered_palette, val_scale)
}
\arguments{
\item{pseudo_LFC}{output from \code{logFC()} - a matrix of pseudo_LFC values to be plotted between heatmaps}

\item{CovMat_est}{reconstructed covariance matrices based on estimates B^k and Q}

\item{subset_order}{a vector giving what variables should be plotted and in the order that they should be plotted}

\item{subset_name}{(optional) name to be plotted with labeled plots.}

\item{color_pal}{(optional) color palette. defaults to \code{bluered_palette}}

\item{val_scale}{a vector of cutpoints to partition data in reconstructed covariance matrices, \code{length(val_scale) = length(color_pal) + 1}}
}
\value{
a list of lists, suitable for use with any of the layout options.
\code{charts} contains all necessary heatmaps and barcharts, \code{labels} contains labeled versions on the same, for internal reference
}
\description{
Produces all necessary plots for things.
}
\examples{
#generate covariance matrices and estimate sparse parameters
sparse_params <- covmats_etc <- vector(mode="list", length=2)
for(i in 1:length(sparse_params)){
 covmats_etc[[i]] <- step0(X[[i]],2)
 sparse_params[[i]] <- sparse_lambdahat_cardinality(covmats_etc[[i]])
}
#we need to rotate all lambdahats to the ture Lambda values before sparsifying
lambdahat_proc <- vector(mode="list", length=2)
lambdahat_proc[[1]] <- covmats_etc[[1]]$lambdahat
lambdahat_proc[[2]] <- covmats_etc[[2]]$lambdahat
for(j in 1:length(covmats_etc)){
 for(i in 1:dim(covmats_etc[[j]]$lambdahat)[3]){
  lambdahat_proc[[j]][,,i] <- vegan::procrustes(Lambda_vals[[j]][,,i],
  covmats_etc[[j]]$lambdahat[,,i], scale=FALSE, symmetric=FALSE)$Yrot
 }
}
#sparsify
spca_cutoff = 0.01
sps_lambdahat_proc = lambdahat_proc
for(j in 1:length(lambdahat_proc)){
sps_lambdahat_proc$C[[j]] <- trunc_C(lambdahat_proc[[j]], sparse_params[[j]]$col_card)
}
#run the algorithm
test_algo <- vector(mode="list", length=2)
test_algo[[1]] <- estimateBkQ(sps_lambdahat_proc$C[[1]], constraint = 1, qadj = "n")
test_algo[[2]] <- estimateBkQ(sps_lambdahat_proc$C[[2]], constraint = 3,
norm_groups = list(c(1,2), c(3,4) ), qadj = "n")
#create reconstructed covariance and lambdahat matrices
reconstructed_output <- vector(mode="list", length=2)
for(i in 1:length(reconstructed_output)){
 reconstructed_output[[i]] <- recon_covlh(test_algo[[i]])
}
#calculate psuedo-LFC values
contrast_mat <- logfc <- vector(mode="list", length=2)
contrast_mat[[1]] <- matrix(data = c(1,2,1,3,2,3), ncol = 2, byrow=TRUE)
contrast_mat[[2]] <- matrix(data = c(1,2,3,4,1,3,2,4), ncol=2, byrow = TRUE)
logfc[[1]] <- logFC_mat(test_algo[[1]]$Bhat,contrasts=contrast_mat[[1]],
condit_names= c("c1", "c2", "c3"))
logfc[[2]] <- logFC_mat(test_algo[[2]]$Bhat,contrasts=contrast_mat[[2]],
condit_names= c("c1", "c2", "c3", "c4"))
#setup for fancy plots
colvals = c()
colvals[[1]] <- color_break_vals(reconstructed_output[[1]]$recon_cov)
colvals[[2]] <- color_break_vals(reconstructed_output[[2]]$recon_cov)
fancy <- vector(mode = "list", length = 2)
for(i in 1:length(fancy)){
  fancy[[i]] = fancyplots_setup(logfc[[i]], reconstructed_output[[i]]$recon_cov,
  subset_order = 1:ncol(reconstructed_output[[i]]$recon_cov[[1]]), subset_name = "dta order",
  bluered_palette,val_scale = colvals[[i]] )
}
}
