% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DWFM_fa_viz.R
\name{layout_2x2}
\alias{layout_2x2}
\title{Plots fancyplots for 2x2 experimental design}
\usage{
layout_2x2(base_dim = 5, fancyplots_setup_obj_l2, orient, contrast_mat)
}
\arguments{
\item{base_dim}{(optional) an integer value giving the base size for a cell in layout grid.}

\item{fancyplots_setup_obj_l2}{Output from fancyplots_setup. Should be \code{fancyplots_setup_obj$charts} to plot the actual data, or \code{fancyplots_setup_obj$labels} to plot labels}

\item{orient}{\code{orient=1} arranges the heatmaps in a square; \code{orient=2} arranges the heatmaps in a V}

\item{contrast_mat}{The contrast matrix used with \code{logFC_mat()}}
}
\value{
fancyplots for 2x2 experimental design
}
\description{
Plots pseudoLFC bar charts and reconstructed covariance matrices for data having a 2x2 experimental design setup.
}
\examples{
#generate covariance matrices and estimate sparse parameters
sparse_params <- covmats_etc <- vector(mode="list", length=2)
for(i in 1:length(sparse_params)){
 covmats_etc[[i]] <- step0(X[[i]],2)
 sparse_params[[i]] <- sparse_lambdahat_cardinality(covmats_etc[[i]])
}
#we need to rotate all lambdahats to the ture Lambda values before sparsifying
lambdahat_proc <- vector(mode="list", length=2)
lambdahat_proc[[1]] <- covmats_etc[[1]]$lambdahat
lambdahat_proc[[2]] <- covmats_etc[[2]]$lambdahat
for(j in 1:length(covmats_etc)){
 for(i in 1:dim(covmats_etc[[j]]$lambdahat)[3]){
  lambdahat_proc[[j]][,,i] <- vegan::procrustes(Lambda_vals[[j]][,,i],
  covmats_etc[[j]]$lambdahat[,,i], scale=FALSE, symmetric=FALSE)$Yrot
 }
}
#sparsify
spca_cutoff = 0.01
sps_lambdahat_proc = lambdahat_proc
for(j in 1:length(lambdahat_proc)){
sps_lambdahat_proc$C[[j]] <- trunc_C(lambdahat_proc[[j]], sparse_params[[j]]$col_card)
}
#run the algorithm
test_algo <- vector(mode="list", length=2)
test_algo[[1]] <- estimateBkQ(sps_lambdahat_proc$C[[1]], constraint = 1, qadj = "n")
test_algo[[2]] <- estimateBkQ(sps_lambdahat_proc$C[[2]], constraint = 3,
norm_groups = list(c(1,2), c(3,4) ), qadj = "n")
#create reconstructed covariance and lambdahat matrices
reconstructed_output <- vector(mode="list", length=2)
for(i in 1:length(reconstructed_output)){
 reconstructed_output[[i]] <- recon_covlh(test_algo[[i]])
}
#calculate psuedo-LFC values
contrast_mat <- logfc <- vector(mode="list", length=2)
contrast_mat[[1]] <- matrix(data = c(1,2,1,3,2,3), ncol = 2, byrow=TRUE)
contrast_mat[[2]] <- matrix(data = c(1,2,3,4,1,3,2,4), ncol=2, byrow = TRUE)
logfc[[1]] <- logFC_mat(test_algo[[1]]$Bhat,contrasts=contrast_mat[[1]],
condit_names= c("c1", "c2", "c3"))
logfc[[2]] <- logFC_mat(test_algo[[2]]$Bhat,contrasts=contrast_mat[[2]],
condit_names= c("c1", "c2", "c3", "c4"))
#setup for fancy plots
colvals = c()
colvals[[1]] <- color_break_vals(reconstructed_output[[1]]$recon_cov)
colvals[[2]] <- color_break_vals(reconstructed_output[[2]]$recon_cov)
fancy <- vector(mode = "list", length = 2)
for(i in 1:length(fancy)){
  fancy[[i]] = fancyplots_setup(logfc[[i]], reconstructed_output[[i]]$recon_cov,
  subset_order = 1:ncol(reconstructed_output[[i]]$recon_cov[[1]]), subset_name = "dta order",
  bluered_palette,val_scale = colvals[[i]] )
}
#plot fancy plots
layout_2x2(base_dim = 5, fancy[[2]]$charts, orient = 1, contrast_mat[[2]])
layout_2x2(base_dim = 5, fancy[[2]]$labels, orient = 2, contrast_mat[[2]])
}
