% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DWFM_algo.R
\name{trunc_C}
\alias{trunc_C}
\title{Truncates the columns of an array by cardinality.}
\usage{
trunc_C(lambdahat, col_card)
}
\arguments{
\item{lambdahat}{An array}

\item{col_card}{A vector of length \code{dim(lambdahat)[2]}}
}
\value{
Array lambdahat where \code{lambdahat[,i,k]} has \code{col_card[i]} non-zero elements for every \code{k}.
}
\description{
Sets to zero the elements of an array so that each column has a specified number of non-zero elements.
}
\examples{
sparse_params <- covmats_etc <- vector(mode="list", length=2)
for(i in 1:length(sparse_params)){
 covmats_etc[[i]] <- step0(X[[i]],2)
 sparse_params[[i]] <- sparse_lambdahat_cardinality(covmats_etc[[i]])
}
#we need to rotate all lambdahats to the true Lambda values before sparsifying
lambdahat_proc <- vector(mode="list", length=2)
lambdahat_proc[[1]] <- covmats_etc[[1]]$lambdahat
lambdahat_proc[[2]] <- covmats_etc[[2]]$lambdahat
for(j in 1:length(covmats_etc)){
 for(i in 1:dim(covmats_etc[[j]]$lambdahat)[3]){
  lambdahat_proc[[j]][,,i] <- vegan::procrustes(Lambda_vals[[j]][,,i],
  covmats_etc[[j]]$lambdahat[,,i], scale=FALSE, symmetric=FALSE)$Yrot
 }
}
#sparsify
spca_cutoff = 0.01
sps_lambdahat_proc = lambdahat_proc
for(j in 1:length(lambdahat_proc)){
sps_lambdahat_proc$C[[j]] <- trunc_C(lambdahat_proc[[j]], sparse_params[[j]]$col_card)
}
}
