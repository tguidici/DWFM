% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DWFM_algo.R
\name{recon_covlh}
\alias{recon_covlh}
\title{Calculates reconstructed lambdahat and covariance matrices based on the output of \code{estimateBkQ()}.}
\usage{
recon_covlh(method_res, row_subset = NULL)
}
\arguments{
\item{method_res}{The output from \code{estimateBkQ()}.}

\item{row_subset}{Optional subset of rows to use in reconstruction. If \code{NULL}, all rows are used.}
}
\value{
A list containing  reconstructed covariance matrices (recon_cov), and reconstructed lambdahats (recon_lh).
}
\description{
Calculates reconstructed lambdahat and covariance matrices based on the output of \code{estimateBkQ()}.
}
\examples{
sparse_params <- covmats_etc <- vector(mode="list", length=2)
for(i in 1:length(sparse_params)){
 covmats_etc[[i]] <- step0(X[[i]],2)
 sparse_params[[i]] <- sparse_lambdahat_cardinality(covmats_etc[[i]])
}
#we need to rotate all lambdahats to the ture Lambda values before sparsifying
lambdahat_proc <- vector(mode="list", length=2)
lambdahat_proc[[1]] <- covmats_etc[[1]]$lambdahat
lambdahat_proc[[2]] <- covmats_etc[[2]]$lambdahat
for(j in 1:length(covmats_etc)){
 for(i in 1:dim(covmats_etc[[j]]$lambdahat)[3]){
  lambdahat_proc[[j]][,,i] <- vegan::procrustes(Lambda_vals[[j]][,,i],
  covmats_etc[[j]]$lambdahat[,,i], scale=FALSE, symmetric=FALSE)$Yrot
 }
}
#sparsify
spca_cutoff = 0.01
sps_lambdahat_proc = lambdahat_proc
for(j in 1:length(lambdahat_proc)){
sps_lambdahat_proc$C[[j]] <- trunc_C(lambdahat_proc[[j]], sparse_params[[j]]$col_card)
}
test_algo <- vector(mode="list", length=2)
test_algo[[1]] <- estimateBkQ(sps_lambdahat_proc$C[[1]], constraint = 1, qadj = "n")
test_algo[[2]] <- estimateBkQ(sps_lambdahat_proc$C[[2]], constraint = 3,
norm_groups = list(c(1,2), c(3,4) ), qadj = "n")
reconstructed_output <- vector(mode="list", length=2)
for(i in 1:length(reconstructed_output)){
 reconstructed_output[[i]] <- recon_covlh(test_algo[[i]])
}
}
